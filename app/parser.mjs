function identity(data) { return data; }

function to_integer(data) {
    return parseInt(data, 10);
}

function to_boolean(data) {
    return Boolean(to_integer(data));
}

// Ideally this would be generated by parsing the response from `/types`.
// But I didn't want to create an XML parser.
const types = {
    event: [
        { name: "eventId", convert_fn: identity, },
        { name: "category", convert_fn: identity, },
        { name: "subCategory", convert_fn: identity, },
        { name: "name", convert_fn: identity, },
        { name: "startTime", convert_fn: to_integer, },
        { name: "displayed", convert_fn: to_boolean, },
        { name: "suspended", convert_fn: to_boolean, },
    ],
    market: [
        { name: "eventId", convert_fn: identity, },
        { name: "marketId", convert_fn: identity, },
        { name: "name", convert_fn: identity, },
        { name: "displayed", convert_fn: to_boolean, },
        { name: "suspended", convert_fn: to_boolean, },
    ],
    outcome: [
        { name: "marketId", convert_fn: identity, },
        { name: "outcomeId", convert_fn: identity, },
        { name: "name", convert_fn: identity, },
        { name: "price", convert_fn: identity, },
        { name: "displayed", convert_fn: to_boolean, },
        { name: "suspended", convert_fn: to_boolean, },
    ],
}

const DELIMITER = "|"
const ESCAPE = "\\";
const NEW_LINE = "\n";

export function* into_packets(buffer) {
    const packet = new Array(11);

    let escaped = false;
    let last_char;
    let index = -1;

    for (let i = 0; i < buffer.length; i += 1) {
        const char = buffer[i];

        let should_add_char = false;

        if (char === ESCAPE) {
            escaped = true;
        } else if (char === DELIMITER) {
            if (escaped) {
                if (last_char === ESCAPE) {
                    should_add_char = escaped; // Only add it if it was escaped.
                    escaped = false;
                }
            } else {
                index += 1;
                packet[index] = "";
            }
        } else if (char === NEW_LINE && last_char !== NEW_LINE) {
            const result = attempt_convert_packet(buffer, packet);

            if (result) {
                yield result;
            }

            // Reset for the next one.
            index = -1;
        } else {
            should_add_char = true;
        }

        last_char = char;

        if (should_add_char) {
            packet[index] += char;
        }
    }
}

/**
 * Takes an array of packet data and attempts to apply the types to it.
 * If anything fails it logs an error and skips the packet.
 */
function attempt_convert_packet(buffer, packet) {
    try {
        const result = {
            head: {
                msgId: to_integer(packet[0]),
                operation: packet[1],
                type: packet[2],
                timestamp: to_integer(packet[3]),
            },
            body: {},
        };

        const type = types[result.head.type];

        if (!type) {
            // FIXME:
            // Report broken input here.

            console.log(buffer);
            console.log(packet);
            console.log(result);
        } else {
            for (let i = 0; i < type.length; i += 1) {
                const { name, convert_fn } = type[i];
                result.body[name] = convert_fn(packet[i + 4]);
            }

            return result;
        }
    } catch (error) {
        // FIXME:
        // Report invalid packet here. This should be logged and skipped.

        console.log(error);
    }
}
